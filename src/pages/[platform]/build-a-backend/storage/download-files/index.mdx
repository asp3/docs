import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Download files',
  description: 'Download files using Amplify Storage',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'vue',
    'android',
    'swift',
    'flutter'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };
}

<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>

## Storage Image UI Component

You can easily display images on your app by using the cloud-connected Storage Image UI component. This component fetches images securely from your storage resource and displays it on the web page.

```bash
npm install @aws-amplify/ui-react-storage aws-amplify
```
```tsx
import { StorageImage } from '@aws-amplify/ui-react-storage';

export const DefaultStorageImageExample = () => {
  return <StorageImage alt="cat" imgKey="cat.jpg" accessLevel="guest" />;
};
```

</InlineFilter>

Learn more about how you can further customize the UI component by referring to the [Storage Image documentation](https://ui.docs.amplify.aws/react/connected-components/storage/storagemanager).

To further customize your in-app experience, you can use the `getUrl` or `downloadData` API from the Amplify Library for Storage.

<Callout>

**Note:** Refer to [the Transfer Acceleration documentation](/[platform]/build-a-backend/storage/extend-s3-resources/#example---enable-transfer-acceleration) to learn how to enable transfer acceleration for storage APIs.

</Callout>

## API to get or download file from URL

Get a presigned URL of a stored file and expiration of URL

<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>

```typescript
import { getUrl } from 'aws-amplify/storage';

const getUrlResult = await getUrl({
  path: "album/2024/1.jpg",
  // Alternatively, path: ({identityId}) => `album/{identityId}/1.jpg`
  options: {
    validateObjectExistence?: false,  // defaults to false
    expiresIn?: 20 // validity of the URL, in seconds. defaults to 900 (15 minutes) and maxes at 3600 (1 hour)
    useAccelerateEndpoint: true; // Whether to use accelerate endpoint.
  },
});
console.log('signed URL: ', getUrlResult.url);
console.log('URL expires at: ', getUrlResult.expiresAt);
```

`getUrl` returns a signed URL in the `url` property of the result. You can use this to create a download link for users to click on. The `expiresAt` property is a `Date` object that represents the time at which the URL will expire.

Inside your template or JSX code, you can use the `url` property to create a link to the file:

```tsx
<a href={signedURL.url.toString()} target="_blank" rel="noreferrer">
  {fileName} 
</a>
```

<Callout>

This function does not check if the file exists by default. As result, the signed URL may fail if the file to be download does not exist.
  
</Callout>

### Check for existence of a file

You can check for the existence of a file in the storage category's `getUrl` API using the `validateObjectExistence` option. When this flag is enabled a `getUrl` call will return a pre-signed URL if the file exists and raise a `404` error if it does not. This allows you to check if an object exists during generating the presigned URL, which you can then use to download that object.

```javascript
import { getUrl } from 'aws-amplify/storage';

// To check for existence of a file
await getUrl({
  path: "album/2024/1.jpg",
  // Alternatively, path: ({identityId}) => `album/{identityId}/1.jpg`
  options: {
    validateObjectExistence: true // defaults to false
  }
});
```

### Set expiry for presigned URL

You can use `expiresIn` option to limit the availability of your URLs. This configuration returns the pre-signed URL that expires in 60 seconds:

```javascript
import { getUrl } from 'aws-amplify/storage';

await getUrl({ 
  path: "album/2024/1.jpg",
  // Alternatively, path: ({identityId}) => `album/{identityId}/1.jpg`
  options: { expiresIn: 60 } 
});
```
<Callout>
  The expiration time of the presigned url is dependent on the session and will
  max out at 1 hour.
</Callout>


</InlineFilter>

<InlineFilter filters={["android"]}>
<BlockSwitcher>
<Block name="Java">

```java
Amplify.Storage.getUrl(
    StoragePath.fromString("public/example"),
    result -> Log.i("MyAmplifyApp", "Successfully generated: " + result.getUrl()),
    error -> Log.e("MyAmplifyApp", "URL generation failure", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Storage.getUrl(
    StoragePath.fromString("public/example"),
    { Log.i("MyAmplifyApp", "Successfully generated: ${it.url}") },
    { Log.e("MyAmplifyApp", "URL generation failure", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val url = Amplify.Storage.getUrl(StoragePath.fromString("public/example")).url
    Log.i("MyAmplifyApp", "Successfully generated: $url")
} catch (error: StorageException) {
    Log.e("MyAmplifyApp", "URL generation failure", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Storage.getUrl(StoragePath.fromString("public/example")).subscribe(
    result -> Log.i("MyAmplifyApp", "Successfully generated: " + result.getUrl()),
    error -> Log.e("MyAmplifyApp", "URL generation failure", error)
);
```

</Block>
</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={["swift"]}>
```swift
let url = try await Amplify.Storage.getURL(path: .fromString("public/example/path"))
print("Completed: \(url)")
```

When creating a downloadable URL, you can choose to check if the file exists by setting `validateObjectExistence` to
`true` in `AWSStorageGetURLOptions`. If the file is inaccessible or does not exist, a `StorageError` is thrown.
This allows you to check if an object exists during generating the presigned URL, which you can then use to download
that object.

```swift
let url = try await Amplify.Storage.getURL(
    path: .fromString("public/example/path"),
    options: .init(
        pluginOptions: AWSStorageGetURLOptions(
            validateObjectExistence: true
        )
    )
)
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>

When creating a downloadable URL, you can choose to check if the file exists by setting `validateObjectExistence` to
`true` in `S3GetUrlPluginOptions`. If the file is inaccessible or does not exist, a `StorageException` is thrown.
This allows you to check if an object exists during generating the presigned URL, which you can then use to download
that object.

```dart
Future<String> getDownloadUrl({
  required String key,
  required StorageAccessLevel accessLevel,
}) async {
  try {
    final result = await Amplify.Storage.getUrl(
      key: key,
      options: const StorageGetUrlOptions(
        accessLevel: accessLevel,
        pluginOptions: S3GetUrlPluginOptions(
          validateObjectExistence: true,
          expiresIn: Duration(days: 1),
        ),
      ),
    ).result;
    return result.url.toString();
  } on StorageException catch (e) {
    safePrint('Could not get a downloadable URL: ${e.message}');
    rethrow;
  }
}
```

</InlineFilter>

## API to download to file

<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>

Use the `downloadData` API to download the file locally on the client.

```javascript
import { downloadData } from 'aws-amplify/storage';

// Downloads file content to memory
const { body, eTag } = await downloadData({
  path: "/album/2024/1.jpg",
  options: {
    // optional progress callback
    onProgress: (event) => {
      console.log(event.transferredBytes);
    }
    // optional bytes range parameter to download a part of the file, the 2nd MB of the file in this example
    bytesRange: {
      start: 1024,
      end: 2048
    }
  }
}).result;
```
</InlineFilter>

<InlineFilter filters={["android"]}>

Use the `downloadFile` API to download the file locally on the client.

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Storage.downloadFile(
        StoragePath.fromString("public/example"),
        new File(getApplicationContext().getFilesDir() + "/download.txt"),
        result -> Log.i("MyAmplifyApp", "Successfully downloaded: " + result.getFile().getName()),
        error -> Log.e("MyAmplifyApp",  "Download Failure", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val file = File("${applicationContext.filesDir}/download.txt")
Amplify.Storage.downloadFile(StoragePath.fromString("public/example"), file,
    { Log.i("MyAmplifyApp", "Successfully downloaded: ${it.file.name}") },
    { Log.e("MyAmplifyApp",  "Download Failure", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val file = File("${applicationContext.filesDir}/download.txt")
    val download = Amplify.Storage.downloadFile(StoragePath.fromString("public/example"), file)
    try {
        val fileName = download.result().file.name
        Log.i("MyAmplifyApp", "Successfully downloaded: $fileName")
    } catch (error: StorageException) {
        Log.e("MyAmplifyApp", "Download Failure", error)
    }
}
```

</Block>
<Block name="RxJava">

```java
RxProgressAwareSingleOperation<StorageDownloadFileResult> download =
        RxAmplify.Storage.downloadFile(
            StoragePath.fromString("public/example"),
            new File(getApplicationContext().getFilesDir() + "/download.txt"
        );

download
    .observeResult()
    .subscribe(
        result -> Log.i("MyAmplifyApp", "Successfully downloaded: " + result.getFile().getName()),
        error -> Log.e("MyAmplifyApp",  "Download Failure", error)
    );
```

</Block>
</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={["swift"]}>

Use the `downloadFile` API to download the file locally on the client.

You can download to a file [URL](https://developer.apple.com/documentation/foundation/url) with `Amplify.Storage.downloadFile`:

<BlockSwitcher>

<Block name="Async/Await">

```swift
let downloadToFileName = FileManager.default.urls(
    for: .documentDirectory,
    in: .userDomainMask
)[0].appendingPathComponent("myFile.txt")

let downloadTask = Amplify.Storage.downloadFile(
    path: .fromString("public/example/path"),
    local: downloadToFileName,
    options: nil
)
Task {
    for await progress in await downloadTask.progress {
        print("Progress: \(progress)")
    }
}
try await downloadTask.value
print("Completed")
```

</Block>

<Block name="Combine">

```swift
let downloadToFileName = FileManager.default.urls(
    for: .documentDirectory,
    in: .userDomainMask
)[0].appendingPathComponent("myFile.txt")

let downloadTask = Amplify.Storage.downloadFile(
    path: .fromString("public/example/path"),
    local: downloadToFileName,
    options: nil
)
let progressSink = downloadTask
    .inProcessPublisher
    .sink { progress in
        print("Progress: \(progress)")
    }

let resultSink = downloadTask
    .resultPublisher
    .sink {
        if case let .failure(storageError) = $0 {
            print("Failed: \(storageError.errorDescription). \(storageError.recoverySuggestion)")
        }
    }
    receiveValue: {
        print("Completed")
    }
```

</Block>

</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["flutter"]}>

You can download a file to a local directory using `Amplify.Storage.downloadFile`.

You can use the [path_provider](https://pub.dev/packages/path_provider) package to create a local file in the user's documents directory where you can store the downloaded data.

<BlockSwitcher>

<Block name = "Mobile & Desktop">

```dart
import 'package:amplify_flutter/amplify_flutter.dart';
import 'package:path_provider/path_provider.dart';

Future<void> downloadFile() async {
  final documentsDir = await getApplicationDocumentsDirectory();
  final filepath = '${documentsDir.path}/example.txt';
  try {
    final result = await Amplify.Storage.downloadFile(
      path: const StoragePath.fromString('public/example.txt'),
      localFile: AWSFile.fromPath(filepath),
    ).result;
    safePrint('Downloaded file is located at: ${result.localFile.path}');
  } on StorageException catch (e) {
    safePrint(e.message);
  }
}
```

</Block>

<Block name = "Web">

On Web, the download process will be handled by the browser. You can provide the downloaded file name by specifying the `path` parameter of `AWSFile.fromPath`. E.g. this instructs the browser to download the file `download.txt`.

```dart
import 'package:amplify_flutter/amplify_flutter.dart';

Future<void> downloadFile() async {
  try {
    final result = await Amplify.Storage.downloadFile(
      path: const StoragePath.fromString('public/example.txt'),
      localFile: AWSFile.fromPath('download.txt'),
    ).result;
    safePrint('Downloaded file: ${result.downloadedItem.path}');
  } on StorageException catch (e) {
    safePrint(e.message);
  }
}
```

</Block>

</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>
### Get the text value of downloaded File

You can get the value of file in any of the three formats: `blob`, `json`, or `text`. You can call the respective method on the `body` property to consume the set data in the respective format.

```javascript
import { downloadData } from 'aws-amplify/storage';

try {
  const downloadResult = await downloadData({ 
    path: "/album/2024/1.jpg" 
  }).result;
  const text = await downloadResult.body.text();
  // Alternatively, you can use `downloadResult.body.blob()`
  // or `downloadResult.body.json()` get read body in Blob or JSON format.
  console.log('Succeed: ', text);
} catch (error) {
  console.log('Error : ', error);
}
```
</InlineFilter>

<InlineFilter filters={["swift"]}>

## API to download data in memory

You can download to in-memory buffer [Data](https://developer.apple.com/documentation/foundation/data) object with `Amplify.Storage.downloadData`:

<BlockSwitcher>

<Block name="Async/Await">

```swift
let downloadTask = Amplify.Storage.downloadData(path: .fromString("public/example/path"))
Task {
    for await progress in await downloadTask.progress {
        print("Progress: \(progress)")
    }
}
let data = try await downloadTask.value
print("Completed: \(data)")
```

</Block>

<Block name="Combine">

```swift
let downloadTask = Amplify.Storage.downloadData(path: .fromString("public/example/path"))
let progressSink = downloadTask
    .inProcessPublisher
    .sink { progress in
        print("Progress: \(progress)")
    }

let resultSink = downloadTask
    .resultPublisher
    .sink {
        if case let .failure(storageError) = $0 {
            print("Failed: \(storageError.errorDescription). \(storageError.recoverySuggestion)")
        }
    }
    receiveValue: { data in
        print("Completed: \(data)")
    }
```

</Block>

</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>
### Monitor download progress

```javascript
import { downloadData } from 'aws-amplify/storage';

// Download a file from s3 bucket
const { body, eTag } = await downloadData(
  {
    path: "/album/2024/1.jpg",
    options: {
      onProgress: (progress) {
        console.log(`Download progress: ${(progress.transferredBytes/progress.totalBytes) * 100}%`);
      }
    }
  }
).result;
```

### Cancel download

```javascript
import { downloadData, isCancelError } from 'aws-amplify/storage';

const downloadTask = downloadData({ path: "/album/2024/1.jpg" });
downloadTask.cancel();
try {
  await downloadTask.result;
} catch (error) {
  if (isCancelError(error)) {
    // Handle error thrown by task cancellation.
  }
}
```
</InlineFilter>

<InlineFilter filters={["android"]}>

### Monitor download progress

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Storage.downloadFile(
        StoragePath.fromString("public/example"),
        new File(getApplicationContext().getFilesDir() + "/download.txt"),
        StorageDownloadFileOptions.defaultInstance(),
        progress -> Log.i("MyAmplifyApp", "Fraction completed: " + progress.getFractionCompleted()),
        result -> Log.i("MyAmplifyApp", "Successfully downloaded: " + result.getFile().getName()),
        error -> Log.e("MyAmplifyApp",  "Download Failure", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val file = File("${applicationContext.filesDir}/download.txt")
val options = StorageDownloadFileOptions.defaultInstance()
Amplify.Storage.downloadFile(StoragePath.fromString("public/example"), file, options,
    { Log.i("MyAmplifyApp", "Fraction completed: ${it.fractionCompleted}") },
    { Log.i("MyAmplifyApp", "Successfully downloaded: ${it.file.name}") },
    { Log.e("MyAmplifyApp", "Download Failure", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val file = File("${applicationContext.filesDir}/download.txt")
val options = StorageDownloadFileOptions.defaultInstance()
val download = Amplify.Storage.downloadFile(StoragePath.fromString("public/example"), file, options)
val progressJob = activityScope.async {
    download.progress().collect { progress ->
        Log.i("MyAmplifyApp", "Fraction completed: ${progress.fractionCompleted}")
    }
}
try {
    val fileName = download.result().file.name
    Log.i("MyAmplifyApp", "Successfully downloaded: $fileName")
} catch (error: StorageException) {
    Log.e("MyAmplifyApp", "Download Failure", error)
}
progressJob.cancel()
```

</Block>
<Block name="RxJava">

```java
RxProgressAwareSingleOperation<StorageDownloadFileResult> download =
        RxAmplify.Storage.downloadFile(StoragePath.fromString("public/example"), localFile);

download
    .observeProgress()
    .subscribe(
      progress -> Log.i("MyAmplifyApp", progress.getFractionCompleted())
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["flutter"]}>

### Monitor download progress

```dart
final operation = Amplify.Storage.downloadData(
  path: const StoragePath.fromString('public/example.txt'),
  onProgress: (progress) {
    safePrint('fraction totalBytes: ${progress.totalBytes}');
    safePrint('fraction transferredBytes: ${progress.transferredBytes}');
    safePrint('fraction completed: ${progress.fractionCompleted}');
  },
);
```

</InlineFilter>

<InlineFilter filters={["android"]}>

### Query transfers

When an upload or download operation is requested using the Amplify Android library, the request is first persisted in the local SQLite Database and then queued for execution. You can query the transfer operation queued in the local database using the transfer ID returned by an upload or download API. Get-Transfer API could retrieve a pending transfer previously en-queued and enable attaching a listener to receive updates on progress change, on-error or on-success, or pause, cancel or resume it.
<BlockSwitcher>
<Block name="Java">

```java
Amplify.Storage.getTransfer("TRANSFER_ID",
    operation -> {
        Log.i("MyAmplifyApp", "Current State" + operation.getTransferState());
        // set listener to receive updates
        operation.setOnProgress( progress -> {});
        operation.setOnSuccess( result -> {});
        operation.setOnError(error -> {});

        // possible actions
        operation.pause();
        operation.resume();
        operation.start();
        operation.cancel();
    },
    {
        error -> Log.e("MyAmplifyApp", "Failed to query transfer", error)
    }
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Storage.getTransfer("TRANSFER_ID",
    { operation ->
        Log.i("MyAmplifyApp", "Current State" + operation.transferState)
        // set listener to receive updates
        operation.setOnProgress {  }
        operation.setOnSuccess {  }
        operation.setOnError {  }

        // possible actions
        operation.pause()
        operation.resume()
        operation.start()
        operation.cancel()
    },
    {
        Log.e("MyAmplifyApp", "Failed to query transfer", it)
    }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val operation = Amplify.Storage.getTransfer("TRANSFER_ID")
    Log.i("MyAmplifyApp", "Current State" + operation.transferState)
    // set listener to receive updates
    operation.setOnProgress {  }
    operation.setOnSuccess {  }
    operation.setOnError {  }

    // possible actions
    operation.pause()
    operation.resume()
    operation.start()
    operation.cancel()
} catch (error: StorageException) {
    Log.e("MyAmplifyApp", "Failed to query transfer", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Storage.getTransfer("TRANSFER_ID")
    .subscribe(
        operation -> {
            Log.i("MyAmplifyApp", "Current State" + operation.getTransferState());
            // set listener to receive updates
            operation.setOnProgress( progress -> {});
            operation.setOnSuccess( result -> {});
            operation.setOnError(error -> {});

            // possible actions
            operation.pause();
            operation.resume();
            operation.start();
            operation.cancel();
        },
        error -> Log.e("MyAmplifyApp", "Failed to query transfer", error);
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["flutter"]}>

## API to download data in memory

You can download a file to in-memory buffer with `Amplify.Storage.downloadData`:

```dart
Future<void> download() async {
  try {
    final result = await Amplify.Storage.downloadData(
      path: const StoragePath.fromString('public/example.txt'),
    ).result;
    safePrint('Downloaded data: ${result.bytes}');
  } on StorageException catch (e) {
    safePrint(e.message);
  }
}
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

### Pause, resume, and cancel downloads

Calls to `downloadData` or `downloadFile` return a reference to the task that is actually performing the download.

To cancel the download (for example, in response to the user pressing a **Cancel** button), you simply call `cancel()` on the download task.

```swift
func cancelDownload() {
    downloadTask.cancel()
}
```

You can also pause and then resume the task.

```swift
downloadTask.pause()
downloadTask.resume()
```


<Callout>

Download tasks are run using `URLSessionTask` instances internally. You can learn more about them in [Apple's official documentation](https://developer.apple.com/documentation/foundation/urlsessiontask).

</Callout>

</InlineFilter>

<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>

## Frequently Asked Questions

Users can run into unexpected issues, so we are giving you advance notice in documentation with links to open issues - please vote for what you need, to help the team prioritize.

- `downloadData` is cached; if you have recently modified a file you may not get the latest version right away. You can pass in `cacheControl: 'no-cache'` to get the latest version.
- `downloadData` only returns the latest cached version of the file; there is [not yet an API to view prior versions](https://github.com/aws-amplify/amplify-js/issues/2131).
- [Image compression](https://github.com/aws-amplify/amplify-js/issues/6081) or CloudFront CDN caching for your S3 buckets is not yet possible.
- There is no API for [Cognito Group-based access to files](https://github.com/aws-amplify/amplify-js/issues/3388).
- There is currently [no API for getting the `identityId` of other users](https://github.com/aws-amplify/amplify-js/issues/5177); you have to retrieve this from elsewhere before calling `Storage.get`.

</InlineFilter>
